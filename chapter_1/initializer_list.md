### *初期化リスト(統一初期化構文)*
---
**概要**
初期化リストとは初期化式であり、初期化リストで使用する構文は全ての変数に対する初期化式として使用可能である。本書では統一初期化構文と初期化リストをまとめて初期化リストとして記載する。この初期化リストを使用することで、複雑なオブジェクトの初期化も容易に記述可能になる。この初期化リストは波カッコの構文で記述する。
元々、波カッコによる初期化構文は配列型、集約型に対してのみ使用可能であった。C++11ではこれが拡張されユーザ定義型にも適用可能になり、統一的な初期化構文として使用できるようになったのである。
また、変数宣言の際にデフォルトコンストラクタを丸カッコで記述すると関数宣言と誤認識する問題があった。この問題に対し、初期化リストの構文を用いることで関数宣言と誤認識する問題を回避することが可能になった。

**サンプル**
```
struct X{};

X f();          //warning デフォルトコンストラクタの呼び出しを意図するが、関数宣言として解釈。
X f{};          //OK デフォルトコンストラクタの呼び出し

class hoge {
public:
    hoge(int a, double b) : a{a}, b{b} {
    }

private:
    int a;
    double b;
};

hoge h1 = {1, 1.3};     //OK デフォルトコンストラクタ呼び出し, C++03では集約型のみ使用可
hoge h2{1, 1.3};        //OK デフォルトコンストラクタ呼び出し

struct Y {
    int a;
    int b;
};

Y y = {1, 2};                           //OK 型Yを初期化リストで初期化
Y y2[3] = { {1,2}, {3, 4}, {5, 6} };    //OK 型Yの配列を初期化リストで初期化
```

この初期化構文は前述の通り、配列にも適用可能である。配列に対して適用する場合、以下のようなルールで扱う。
 * 配列の要素数が指定されている
  * 初期化リストの要素数が配列の要素数より少ない場合は、指定された順で先頭から初期化され、足りない要素数は zero-initialize される
  * 初期化リストの要素数が配列の要素数より多い場合は、ill-formed
  * 初期化リストの要素数と配列の要素数が同じ場合は、指定された順で先頭から初期化
 * 配列の要素数が指定されていない
  * 初期化リストの要素数の配列として宣言されたものとして振舞う。この際、指定された順で初期化。

**サンプル**
```
int a[3] = {1, 2, 3};       //OK
int b[3] {1, 2, 3};         //OK

int c[3] = {1, 2};          //OK c[0]=1, c[1]=2, c[2]=0
int d[3] = {1, 2, 3, 4};    //error

int e[] = {1, 2, 3};        //OK 配列のサイズは3
```

初期化リストの特殊系として、std::initializer_list<T>を使用する方式がある。
これについては、ライブラリの項目を参照。
