### *attribute*
---
#### 概要
C++11では、変数宣言や、関数宣言などソースコード中の様々な箇所に属性(attribute)と呼ばれる、付加情報を記述できるようになった。
属性を指定できる場所についてここで全て列挙しない。標準でサポートされる属性について記述例と共に説明する。

属性は、以下の構文で記述する。
`[[ attribute list ]]`

attribute listは、カンマ区切りで複数の属性が指定可能である。
attribute listに指定可能な標準で定義されている属性は、以下の通りである。

 * noreturn
 * carryies_dependency

また、attribute指定子の一部としての定義されているが、上記の構文を用いずにキーワード alignas を用いてアライメントを規定するアライメント指定子についても説明する。

##### noreturn
noreturnとは、その名が示す通り return することない関数に対して適用可能な属性である。この属性が指定された関数は、呼び出し後 return させることが出来なくなる。もし return した場合、その振る舞いは未定義である。例外送出により termination するかもしれない。例外発生による脱出のみ許可されている。
noreturn属性は、関数の最初の宣言時に指定されていなければならない。

```c++
[[ noreturn ]] void no_return() {
    while(true) {                   //OK return することがない
    }
}

[[ noreturn ]] void no_return2() {
    throw "error";                  //OK 例外による脱出は許可
}
```

##### caries_dependency
caries_dependencyとは、関数の内部へ、そして外に対して依存性の伝搬を宣言する。caries_dependencyは、最適化に対するヒントである。
また、このヒントが有効に使用されるのは、弱い順序付けメモリモデルのアーキテクチャの場合だそうだ。

この属性は、関数と関数の引数に指定することができ、関数に指定した場合は関数の実行は関数の戻り値に依存性が伝搬することを示す。
関数からの復帰時に戻り値への依存以外に順序性の制約がないことを表現する。

関数の引数に指定された場合は、その引数に関して関数内部に依存性が伝搬されることを示す。

```c++
[[carries_depencency]] struct foo* f(int i);
int* g(int* x, [[carries_depencency]] int* y);
```


##### アライメント指定子
アライメントとは実装定義の整数値であり、これは一つのオブジェクトを配置するための連続したバイト数をしめす。
オブジェクト型はアライメント要件を持ち、この要件はオブジェクトのアドレス上での配置制約である。
例えば、アライメントが4byteであるならば、4の倍数のメモリ上に構築される。
アライメント指定子は、変数、クラスのデータメンバ(ビットフィールド除く)、クラスもしくは列挙子に指定できる。
アライメント指定子に "..."を含んだ指定が行われると、パック展開が行われる。(Variable Template 参照)

アライメント指定を指定可能なポイントは、属性を指定可能なポイントである。
これは、元々アライメント指定を属性で定義しようとしていたためである。

以下にアライメント指定子の構文を示す。
```
alignas(型)
alignas(整数を返す定数式)
```

あるオブジェクト型のアライメント要件を取得するオペレータとして、 alignof() が追加されている。
alignas(型) と alignas( alignof(型) ) は同じ効果を持つ。

