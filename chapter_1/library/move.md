### **forward / move**
---
#### 概要
C++11にはr-value、ムーブセマンティクスという概念が追加されている事を記述した。
ムーブとはある変数の所有権を別の変数へ移譲する事であるため、一時的なテンポラリオブジェクトであるr-valueのみに適用可能である。
しかし実際には、使用しなくなるローカル変数(lvalue)を関数の引数へムーブしたい、関数内で作成したlvalueを関数の外へムーブしたい、
という用途が多い。 そこで、ムーブセマンティクスを示す *std::move* を利用する。

`std::move`は、ヘッダファイル**utility**をインクルードする事で使用可能となる。

以下に、上記の２パターンについて実装する場合の例を記載する。
* 関数呼び出し時のムーブ

```c++
#include <utility>>

class X{
public:
   X() {}
};

void func(X v) {
}

int main() {
    X x;
    func(std::move(x));
}
```

* 関数の戻り値をムーブ

```c++
#include <utility>>

class X{
public:
   X() {}
};

X func() {
    X x;
    return std::move(x);
}

int main() {
    X x = func();
}
```
関数の戻り値をムーブする場合の注意点として、戻り値の型は rvalue参照 ではないという点である。
関数を抜けた時点でローカル変数は破棄されるため、無効な参照となるためである。関数内のローカル変数をlvalue参照として返却できないのと同じ理屈となる。



forwardについては、後で追記
