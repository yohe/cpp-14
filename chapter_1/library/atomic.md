### *atomic*
---
#### 概要
atomicとは、アトミック操作を実現するテンプレートクラス*atomic*を提供するライブラリである。atomic型を使用することでロックフリーなプログラムを作成可能となる。
atomic型を適切に使用するには、メモリモデル、およびフェンス(メモリバリア)についての理解が必要になる。

##### メモリモデル
メモリモデルを説明するのは非常に難しいため、メモリモデルの一部のみを扱う。そして、メモリバリアとその必要性について説明し、atomicでの表現方法を示すことにする。
本書で記述するメモリモデルとは、メモリ一貫性モデルを指す。一般的な内容は、[consistency model](https://en.wikipedia.org/wiki/Consistency_model)を参照してほしい。

メモリ一貫性モデルとは、マルチスレッドで動作するプログラム上の変数に対するアクセス(読み/書き)がどのような順序で実行されるかのルールを定義したものである。
メモリ一貫性モデルにおいて一番基本的なモデルが逐次一貫性モデルである。

> 逐次一貫性モデルとは、どのような実行結果も、すべてのプロセッサがある順序で逐次的に実行した結果と等しく、
> かつ、個々のプロセッサの処理順序がプログラムで指定された通りであること
> Wikipedia引用

上記の内容は当たり前のように感じられるかもしれないが、これを満たさないメモリ一貫性モデルも存在する。
例えば、Total Store Ordering model(TSO), Relaxed consistency model(XC)などがある。これらはメモリアクセス命令をプログラム順とは異なる順で発行すること許容したメモリモデルである。分かりやすい例を挙げるならば、あるメモリの読み込み命令を実行する際に、そのメモリのデータがキャッシュ上にない、もしくは古いデータの場合にはメモリから読み込むまで待ち時間が発生する。この時に、高速化のために後続するメモリアクセス命令を実行する時である。

このようなプログラム順とメモリアクセス順がことなる順で実行されることをアウトオブオーダ実行と呼ぶ。
※ このアウトオブオーダはプログラムの最適化によっても引き起こされる可能性がある。


アウトオブオーダ実行について考えてみる。例えば、以下のコードを実行した場合、v1, v2がどのような値を持つか考える。
なお、データ競合は発生しないものとする。

```c++
#include <thread>
#include <iostream>

int A = 0;
int B = 0;
int C = 0;

int v1 = 0;
int v2 = 0;

void thread1() {
    A = 1;
    B = 1;
}

void thread2() {
    A = 2;
    C = 1;
}

void thread3() {
    while(B != 1) {}
    while(C != 1) {}
    v1 = A;
}

void thread4() {
    while(B != 1) {}
    while(C != 1) {}
    v2 = A;
}

int main() {
    std::thread t1(thread1);
    std::thread t2(thread2);
    std::thread t3(thread3);
    std::thread t4(thread4);

    std::cout << "v1 : " << v1 << std::endl;
    std::cout << "v2 : " << v2 << std::endl;

    t1.join();
    t2.join();
    t3.join();
    t4.join();
    return 0;
}
```

このプログラムをマルチコア環境で実行した時、v1, v2の値が異なる値を保持する場合がある。これは、あるCPU-Aで実行された書き込み処理が、CPU-Bに反映されるタイミングがプログラム順と異なる順で行われることにより発生するためである。つまりアウトオブオーダ実行が発生する場合である。
アウトオブオーダーはプログラムの最終的な動作に影響がないように行われるが、これは実行している実行スレッドに対してのみ考慮される。従って、複数スレッドで動作するプログラムの場合、アウトオブオーダは予期しない動作を引き起こす可能性がある。

以下に、筆者の環境で複数回実行した際のパターンを示しておく。
```
-- パターン1
v1 : 0
v2 : 0
-- パターン2
v1 : 2
v2 : 2
-- パターン3
v1 : 1
v2 : 1
-- パターン4
v1 : 0
v2 : 1
-- パターン5
v1 : 0
v2 : 2
```

さて、このように逐次一貫性をハードウェアレベルで保証できないケースがある。そのため、ハードウェア側で順序性を保証する機能を提供している。それがフェンス(メモリバリア)である。C++におけるatomic操作はatomicな変数アクセスに加え、このフェンス機能を提供する。

C++ではatomic操作を行うにあたり、atomicでない変数のメモリオーダがどのように振る舞うかを指定することができる。
メモリオーダを考えるとき、以下のような分類で考えることができる。
 * Load -> Load
 * Load -> Store
 * Store -> Load
 * Store -> Store

上記は、矢印の左のメモリ操作の後に、右のメモリ操作が行われるメモリ操作順を示している。逐次一貫性モデルの場合、メモリ操作順はプログラム順と同じであることは前述した。しかし、それ以外のモデルの場合には同じ順に行われない可能性がある。つまり左のメモリ操作と右のメモリ操作が逆転する場合である。この逆転を防ぐためにフェンスを用いる。C++におけるフェンスは以下の種類に分類されている。

| フェンス | 保証する動作 |
| -- | -- |
| Acquire fence | Load -> Load, Load -> Store |
| Release fence | Load -> Store, Store -> Store |

Acquire fenceとは、フェンスに続く任意のメモリ操作が必ずフェンスの後に実行されることを示す。また、Acquire fenceはLoad操作に指定可能である。
Release fenceとは、フェンスの前の任意のメモリ操作が必ずフェンスの前に実行されることを示す。また、Release fenceはStore操作に指定可能である。

上記の表を見ると、Store -> Load 操作に対する保証がないことがわかる。つまり、Acquire fence, Release fenceだけでは全てのメモリ操作の組み合わせに対する順序保証を提供できない。

| メモリオーダ | 動作 |
| -- | -- |
| std::memory_order_relaxed | メモリオーダに対して何も作用しない。atomicな操作のみを提供 |
| std::memory_order_release | Release fenceを実現する |  
| std::memory_order_acquire | Acquire fenceを実現する |  
| std::memory_order_acq_rel | Relase fence、Acquire fenceの両方を実現する |  
| std::memory_order_consume | Acquire fence(読み込んだ変数に依存する操作に対してのみ保証) |
| std::memory_order_seq_cst | 逐次一貫性を実現する |

atomicライブラリを理解するための基礎を記述できた。ここからatomicライブラリの説明に入る。

##### atomicライブラリ
atomic型は、組み込み型をテンプレート引数として受け取る。特殊化済みのtypedefも提供されている。同じであるためここでは、atomic<T>で表現する。
atomic型は、load(読み込み), store(書き込み)などの操作を提供しており、各操作に対して、メモリオーダを指定できるようになっている。
つまり、std::memory_order_acquireを指定することで、Acquire fenceを含めて提供することができる。指定しない場合はデフォルト動作として、std::memory_order_seq_cstが指定されたものとして動作する。
なお、atomic型に定義されている全てのオペレーションはフリー関数としても提供されている。例えば、atomic<T>.load()については、atomic_load()関数というように定義されている。
また、純粋にfence機能のみを提供する、atomic_thread_fnce関数もある。

2つのatomic型変数(A,B)が、Release fence(A)、Acquire fence(B)を提供する場合で、かつA -> Bの順序関係がある場合、この関係を "Synchronized with"関係と呼ぶ。

