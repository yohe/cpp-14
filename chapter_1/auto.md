### *auto*
---
#### 概要

C++03で自動変数(auto変数)を宣言する際の記憶クラス指定子であったが、基本的に指定されることがない(ブロックスコープの変数はデフォルトで指定される)ためC++11において廃止となり、型推論を示す型として再定義された。
autoを変数を宣言する際の型として指定すると、変数の型は、型推論により宣言に続く初期化式の結果の型として宣言されたものとして振舞う。
従って、autoを指定した変数宣言には、必ず初期化式が必須となる。


**サンプル**

```
class X {
public:
    X() {}
    X(const X& lhs) {
    }
};

X f();
X& f_ref();

int main(int argc, char** argv) {
    auto i = 1;             // int
    auto f = 1.0f;          // float
    auto d = 10.0;          // double

    auto v = f();           // X
    auto & v_ref = f_ref(); // X &
}
```

また、このキーワード"auto"は、関数の戻り値の型推論にも使用することができる。但しreturn文からの型推論ではなく、
trailling return typeと呼ばれる後置形の型指定の式の結果によって決定する。

**サンプル**
```
auto func() -> int {
    return 0;
}

auto func() -> double {
    return 0;
}
```

さて、autoによる変数宣言を行うと(特に初期化式に関数呼び出しが含まれる場合)、変数の型が人間には判断しづらくなるというデメリットがある。
だが、最近の開発環境では関数宣言へのジャンプ機能などにより大きな問題になることは少ないと思われる。それよりも、autoによる型のロバスト性獲得であったり、
コンパイラによる最適な型の選択によるメリットの方が大きい場合もあると考える。

autoで宣言された変数と同じ型の変数を再度作成したいと言った場合もある。この場合、decltype指定子というものを使用する。
decltype指定子とは、decltype(式)という記述で型を表すことができ、表される型は、decltypeに指定した式の結果の型である。
また、decltypeで指定した式は評価されない(ランタイム中に実行されない)。

**サンプル**
```
double f();

auto i=1;           //i is int
decltype(i) j;      //j is int
decltype(f()) d;    //d is double
```

