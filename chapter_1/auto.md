### *auto*
---
#### 概要

C++03で自動変数(auto変数)を宣言する際の記憶クラス指定子であったが、基本的に指定する必要がない(ブロックスコープの変数はデフォルトで指定される)ためC++11において廃止となり、型推論を示す型として再定義された。
キーワード"auto"を変数を宣言する際の型として指定すると、autoの型は初期化式からの型推論により決定される。
従って、autoを指定した変数宣言には、必ず初期化式が必須となる。
また、型推論の結果の型は、初期化式をテンプレート関数に渡した際に使用される型と一致する。
autoは型指定子であるため、他の型指定子と同様にcv修飾子、参照修飾子も付加可能となる。

```c++
class X {
public:
    X() {}
    X(const X& lhs) {
    }
};

X f();
X& f_ref();

int main(int argc, char** argv) {
    auto i = 1;             // int
    auto f = 1.0f;          // float
    auto d = 10.0;          // double

    auto v = f();           // X
    auto & v_ref = f_ref(); // X &
}
```

また、このキーワード"auto"は、関数の戻り値の型推論にも使用することができる。但しreturn文からの型推論ではなく、
trailling return typeと呼ばれる後置形の型指定の式の型推論から決定する。

**サンプル**
```
auto func() -> int {
    return 0;
}

auto func() -> double {
    return 0;
}
```

さて、autoによる変数宣言を行うと(特に初期化式に関数呼び出しが含まれる場合)、変数の型が人間には判断しづらくなるというデメリットがある。
だが、最近の開発環境では関数宣言へのジャンプ機能などがあるため大きな問題になることは少ないと思われる。それよりも、autoによる型のロバスト性獲得であったり、
コンパイラによる最適な型の選択によるメリットの方が大きい場合もあると考える。

autoで宣言された変数と同じ型の変数を再度作成したいと言った場合もある。この場合、decltype指定子というものを使用する。
decltype指定子とは、decltype(式)という記述で型を表すことができ、ここで表される型はdecltypeに指定した式の結果の型である。
また、decltypeで指定した式は評価されない(ランタイム中に実行されない)。


```c++
double f();

auto i=0;           //i is int
decltype(i++) j;    //j is int
decltype(f()) d;    //d is double

std::cout << i << std::endl; // 0
```

